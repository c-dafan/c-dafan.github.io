<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[GoNote]]></title>
      <url>%2F04%2F09%2FGoNote%2F</url>
      <content type="text"><![CDATA[golang你好函数类型 匿名函数go 函数也是一种类型，用于声明变量，接收变量值 12345678910package mainimport "fmt"type myFunc func(a int, b int) intfunc main()&#123; var myfunc myFunc myfunc = func(a int, b int) int &#123; return a+b &#125; fmt.Println(myfunc(1,2))&#125; 回调函数把函数当作一个参数 12345678910111213type myFunc func(a int, b int) intfunc calu(a int, b int, myfunc myFunc) int &#123; return myfunc(a, b)&#125;func main()&#123; var myfunc myFunc myfunc = func(a int, b int) int &#123; return a+b &#125; fmt.Println(calu(1,2, myfunc))&#125; 闭包闭包中变量，一直存在 12345678910111213func test02() func() int&#123; vv := 1 return func() int&#123; vv++ return vv &#125;&#125;func main()&#123; f := test02() fmt.Println(f()) fmt.Println(f())&#125; 匿名导入1import _ "fmt" 执行init函数 匿名字段继承 定义与初始化12345678910111213141516171819202122232425type people struct&#123; name string age int sex byte&#125;type student struct&#123; people id int&#125;func main() &#123; s := student&#123;people&#123;"aa",16,'m'&#125;,150706&#125; fmt.Println(s) s2 := student&#123;people:people&#123;name:"bb"&#125; id:160706&#125; fmt.Println(s2) // s3 := student&#123;"aa",16,'m',150706&#125; 错误用法 s4 := student&#123;&#125; s4.id = 170706 s4.name = "cc" s4.age = 17 s4.sex = 'm' fmt.Println(s4)&#125; 非结构字段12345678910111213141516171819202122type people struct&#123; name string age int sex byte&#125;type student struct&#123; people int&#125;func main() &#123; s := student&#123;people&#123;"aa",16,'m'&#125;,150706&#125; fmt.Println(s) s4 := student&#123;&#125; s4.int = 170706 s4.name = "cc" s4.age = 17 s4.sex = 'm' fmt.Println(s4)&#125; 同名字段就近原则 方法值与引用12345678910111213141516171819202122232425type people struct&#123; name string age int sex byte&#125;func (this *people) setinfoPointer()&#123; this.name = "a" this.age = 12 this.sex = 'm'&#125;func (this people) setinfo()&#123; this.name = "a" this.age = 12 this.sex = 'm'&#125;func main() &#123; p := people&#123;&#125; p.setinfo() // 无效 fmt.Println(p) p.setinfoPointer() fmt.Println(p)&#125; 接口空接口 类型断言12345678910111213141516171819202122232425262728293031type people struct&#123; name string age int sex byte&#125;func main() &#123; ii := make([]interface&#123;&#125;, 3) ii[0] = 1 ii[1] = "2" ii[2] = people&#123;name:"3"&#125; for _,d := range ii &#123; if val, ok:=d.(int); ok&#123; fmt.Println("int",val) &#125;else if val, ok:=d.(string); ok&#123; fmt.Println("string",val) &#125;else if val, ok:=d.(people); ok&#123; fmt.Println("people",val) &#125; &#125; for _,d := range ii &#123; switch value := d.(type) &#123; case int: fmt.Println("int",value) case string: fmt.Println("string",value) case people: fmt.Println("people",value) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试准备]]></title>
      <url>%2F04%2F07%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
      <content type="text"><![CDATA[面试前准备 pythonpython面试题 javajava面试题 redisredis入门 rabbitmqrabbitmq复习 rabbitmq复习 springbootspringbootspringboot gogolang go]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shop_go_vue]]></title>
      <url>%2F04%2F05%2Fshop-go-vue%2F</url>
      <content type="text"><![CDATA[一个购物网站总结一个购物网站，数据库设计如下： 前端nodejs + vue-cli + Vue + Element-UI vue采用element-UI组件。记录一下体验： vue整体体验很好，通过router和router-view可以很好的提高前端布局代码的复用性。对我这种不擅长写前端，每次写前端ctrl+c，ctrl+v的真的是非常的友好。另外，数据的绑定、一些指令也是相当的好用 使用vue-cli工具，需要借助nodejs，可以实现前后端的分离。在vue-cli的工程上，目录结构很清晰，很容易写一个前端。不过需要一些nodejs的知识，不然学起来真的很难受。 element-UI组件很好使用，不用懂很多css也能写出来很漂亮页面，有种纯写html最后得到带css效果的页面。 笔记： 父子组件通信 v-model 数据双向绑定 v-on （@）事件 v-bind （:） 数据单向绑定 内置指令 v-if、v-else、v-else-if 条件 v-for 循环 （o, i） in objs 其中i是索引，这个顺序好像和我见过的大部分语言相反 函数 created watch 一直观察这个变量 computed 一个变量通过函数结算出来 slot、props、scope slot 插槽 scope props beegobeego体验： beego从入门到放弃，没有重新运行解决不了的问题，beego基于mvc三层的一个框架，只要学过其他语言的WEB，入手还是很容易的。 学习go语言一天，入手beego，本着练习go语言的原则，写了这个项目。 beego有个bee工具，使用起来很容易。bee generate 几乎直接把真的网站的代码都写完了，需要改一些逻辑。生成的controller中GetAll也太恨了，把整个数据库的信息可以按照任意条件都能查询到。 项目中遇到的问题： 通过注释配url，这个不知道是我的问题，还是beego的问题。配好的url，第一次不起作用，需要把进程关了，然后重新运行。第一次运行会生成一个文件，但是进入url会404，第二次运行就没问题。 beego的orm也很用，很简单的就能和数据库映射。查询外键中的对象很可以查询到，不过一旦用了外键，外键对应的就成为了一个结构体，在发post等请求时，传外键Id时，需要多写一个{}。 beego笔记： bee generate 生成代码 new 创建 pack 打包 run 运行 orm qs.RelatedSel() 加载外键 参数：要加载的外键名字，多层的话，可以使用__ qs.Limit(limit, offset) struct 123456789type Address struct &#123; Id int `orm:"column(aid);auto"` Uid *User `orm:"column(uid);null;rel(fk)"`&#125;// auto自增、// null可以为空、默认为非空、// auto_now_add;type(datetime) 自动放到当时时间// auto_now;type(datetime) 自动放到当时时间// 区别auto_now_add第一次添加的时间，更新时间不变，auto_now每次更新时间改变 Controller router ServeJSON]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>%2F04%2F25%2Fhello%2F</url>
      <content type="text"><![CDATA[博客笔记 自2017年搭建好，再也没用过，两年后的现在重拾博客]]></content>
    </entry>

    
  
  
</search>
