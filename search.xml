<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[go网络编程]]></title>
      <url>%2F04%2F22%2FgoNetWorkCode%2F</url>
      <content type="text"><![CDATA[连接过程监听端口123listener, err := net.Listen("tcp", ":8000")defer listener.Close() 客户端发送请求链接123conn, err := net.Dial("tcp", ":8000")defer conn.Close() 接受客户端请求链接12conn, err := listener.Accept()defer conn.Close() 接收数据12buffer := make([]byte, 2048)n, err := conn.Read(buffer) 发送数据1n, err = conn.Write([]byte(。。。)) server处理单client服务器1234567891011121314151617181920func main() &#123; listener, err := net.Listen("tcp", ":8000") if err != nil &#123; fmt.Println(err) return &#125; defer listener.Close() buffer := make([]byte, 2048) conn, err := listener.Accept() if err != nil &#123; fmt.Println(err) &#125; fmt.Println(conn.RemoteAddr()) n, err := conn.Read(buffer) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(string(buffer[:n])) defer conn.Close()&#125; client12345678910111213141516func main() &#123; conn, err := net.Dial("tcp", ":8000") defer conn.Close() if err != nil &#123; fmt.Println(err) return &#125; buf := make([]byte, 2048) content := "hello world" n, err := conn.Write([]byte(content)) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(n)&#125; server并发处理多client，并保持链接状态server这是使用了go开启一个线程， 当有新的client链接时，都会开启一个go程。如果把go去掉，只能处理单个client，当多个client请求链接时，只有第一个和server保持链接。其余的都在等待状态。有个教学视频说会被替换，经过测试，当不使用go时，线程会被阻塞到读取的位置，只是其余的client在等待，第一个链接的不会被替换。 1234567891011121314151617181920212223242526272829303132333435363738func main() &#123; listener, err := net.Listen("tcp", ":8000") if err != nil &#123; fmt.Println(err) return &#125; defer listener.Close() for &#123; conn, err := listener.Accept() if err!=nil&#123; fmt.Println(err) &#125; go handle(conn) &#125;&#125;func handle(conn net.Conn) &#123; fmt.Println(conn.RemoteAddr()) defer conn.Close() buffer := make([]byte, 2048) for&#123; n, err := conn.Read(buffer) if err != nil &#123; fmt.Println(err) return &#125; content := strings.Trim(string(buffer[:n]), " \r\n") fmt.Println(n, content) if content == "exit"&#123; return &#125; fmt.Println(time.Now()) n, err = conn.Write([]byte(time.Now().String())) if err != nil &#123; fmt.Println(err) &#125; &#125;&#125; client输入exit退出 123456789101112131415161718192021222324252627282930313233func main() &#123; conn, err := net.Dial("tcp", ":8000") defer conn.Close() if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; for &#123; str := make([]byte, 2048) n, err := os.Stdin.Read(str) if err != nil&#123; fmt.Println(err) return &#125; n, err = conn.Write(str[:n]) if err != nil &#123; fmt.Println(err) return &#125; &#125; &#125;() buf := make([]byte, 2048) for&#123; n, err := conn.Read(buf) if err != nil&#123; fmt.Println(err) return &#125; fmt.Println(string(buf[:n])) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[go并发]]></title>
      <url>%2F04%2F17%2Fgo%E5%B9%B6%E5%8F%91%2F</url>
      <content type="text"><![CDATA[管道 channel关闭管道123456789101112131415161718192021222324func main()&#123; ch := make(chan int, 3) go func()&#123; for i:=0;i&lt;15;i++&#123; ch &lt;- i &#125; close(ch) &#125;() // for &#123; // i, ok := &lt;-ch // if ok&#123; // fmt.Println(i) // &#125;else&#123; // break // &#125; // &#125; // for i, ok := &lt;-ch; ok;i, ok = &lt;-ch &#123; // fmt.Println(i) // &#125; for i := range ch&#123; fmt.Println(i) &#125;&#125; 通过close可以关闭管道，关闭后，不能写入东西，不能读取。可以通过ok判断。也可以通过range遍历 单向管道123456789101112131415161718func main()&#123; ch := make(chan int) var readch &lt;-chan int = ch var writech chan&lt;- int = ch // writech&lt;- 0 // fmt.Println(&lt;-readch) // readch &lt;- 0 编译不通过 // &lt;- writech 编译不通过 go func()&#123; for i:=0;i&lt;20;i++&#123; writech &lt;- i &#125; close(ch) &#125;() for i := range readch&#123; fmt.Println(i) &#125;&#125; 有无缓冲管道123456789101112131415func main()&#123; ch := make(chan int, 5) // ch := make(chan int) go func()&#123; for i:=0;i&lt;10;i++&#123; ch &lt;- i fmt.Println("生成：",i) &#125; close(ch) &#125;() for i := range ch&#123; fmt.Println("消费：",i) time.Sleep(time.Second) &#125;&#125; 可以看到有缓冲管道在装满时，阻塞。 runtime的使用让出时间片12345678910func main()&#123; go func() &#123; for i := 0;i&lt;5;i++&#123; fmt.Println("go") &#125; &#125;() for i := 0;i&lt;2;i++&#123; fmt.Println("hello") &#125;&#125; 主线程运行结束，go协程运行没有结束，就会被自动关闭。会没有go的输出。让出时间片，就可以看到go协程的输出。 123456789101112func main()&#123; go func() &#123; for i := 0;i&lt;3;i++&#123; fmt.Println("go") &#125; &#125;() for i := 0;i&lt;2;i++&#123; runtime.Gosched() // 让出时间片 fmt.Println("hello") &#125;&#125; 退出子线程12345678910111213141516171819func test()&#123; defer fmt.Println("cc") // return // runtime.Goexit() fmt.Println("dd")&#125;func main()&#123; ch := make(chan int) go func(ch chan int)&#123; fmt.Println("aa") test() fmt.Println("bb") defer func(ch chan int)&#123; ch &lt;- 0 &#125;(ch) &#125;(ch) &lt;-ch&#125; 输出： aa dd cc bb 取消return的注释后， 会输出： aa cc bb 由此说明，return退出的是函数 取消 runtime.Goexit() 的注释，会输出： aa cc 说明退出了整个线程 最大并行数123456789func main()&#123; n := runtime.GOMAXPROCS(4) fmt.Println(n) for &#123; go fmt.Print("0") fmt.Print(1) &#125;&#125; time的使用定时器的创建12345678func main()&#123; timer := time.NewTimer(2 * time.Second) fmt.Println("时间",time.Now()) t := &lt;-timer.C fmt.Println(t)&#125; 定时2秒钟。 sleep123456func main()&#123; fmt.Println(time.Now()) time.Sleep(2* time.Second) fmt.Println(time.Now())&#125; After12345func main()&#123; fmt.Println(time.Now()) &lt;-time.After(2*time.Second) fmt.Println(time.Now())&#125; stop1234567891011func main()&#123; timer := time.NewTimer(time.Second) go func()&#123; &lt;-timer.C fmt.Println("携程关闭") &#125;() // timer.Stop() for&#123; &#125;&#125; 取消timer.Stop()的注释，子线程将不会结束。因为在stop以后，timer.C 管道中不会有信息。 Reset1234567func main()&#123; fmt.Println(time.Now()) timer := time.NewTimer(3 * time.Second) timer.Reset(time.Second) &lt;-timer.C fmt.Println(time.Now())&#125; 重新设置定时器时间 Ticker123456789101112func main()&#123; ticker := time.NewTicker(time.Second) i:= 0 for _ = range ticker.C &#123; fmt.Println("i=",i) i ++ if i ==5&#123; ticker.Stop() break &#125; &#125;&#125; 可以多次使用的定时器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[conda大坑]]></title>
      <url>%2F04%2F13%2Fconda%E5%A4%A7%E5%9D%91%2F</url>
      <content type="text"><![CDATA[记录一个遇到的坑。是非常的坑的坑。 –conda的使用 conda坑conda installconda的强大，一直也听说过，只是没想到如此的强大。只是想安装一个包，把我的整个python环境全都给我替换了。 我只是想装一下gdcm，但是py37没有这个包，所以pip显示没有匹配到。本着尝试的想法，用conda install，结果把整个环境从python37升级到了py36，（没错是升级，conda是这么提醒的）。当我发现有问题时，非常的绝望，但是怂，只能静悄悄的看着进度条走了半个小时。 结果不错所料，完全不能用了。conda强大到让你绝望中，又有了希望。居然还可以回滚。见回滚使用。 conda使用安装1conda install -n your_env_name [package] 默认装在root下。奇坑，小心着用。 创建环境1conda create -n your_env_name python=X.X（2.7、3.6等) 回滚12conda list --revisionconda install --version N N为回退的版本。 参考 pip清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学: https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 以后还是使用pip]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lightsocks环境配置]]></title>
      <url>%2F04%2F12%2FLightsocks%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[你也能写个 Shadowsocks 环境搭建通过SOCKS5代理，代码见, 代码运行方法很简单，先运行server然后运行local，但是现在有个问题，如何才能让访问通过local的端口发出呢？这个可以通过浏览器设置代理ip和端口，把代理ip和端口设置成local监听的端口，然后就可以访问到local。设置方法： 这里使用的是chrome， 进入设置 进入高级设置 代理设置 这时候会弹出系统弹出窗 局域网（LAN）设置 在新的弹出窗可以看到 现在可以访问local了，local也可以把数据转发到server，但是现在还有一个问题。server是直接把链接断掉，因为这个使用SOCKS5，server发现不是SOCKS5后，就丢弃了。local只是直接做了转发，需要浏览器直接设置为SOCKS5代理。 这个使用的是chrome，需要一个插件 下载插件SwitchyOmega 进入扩展程序，打开开发者模式，把下载的crx文件直接拖进去就可以直接安装了 进入SwitchyOmega界面， 新建模式，填写协议，ip：port 应用选项。 扩展功能在代码中，可见server.go 文件。在文件中，handleConn方法主要做转发处理。所以这里对handleConn方法，这修改就可以了。 输出日志我这里需要建立链接的日志，日志内容包括时间和源ip与目标ip。做一下修改就可以。 首先修改securetcp中struct 123456789101112type Addr interface &#123; Network() string // name of the network (for example, "tcp", "udp") String() string // string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")&#125;// 加密传输的 TCP Sockettype SecureTCPConn struct &#123; io.ReadWriteCloser Address Addr Cipher *cipher&#125;` 然后在这里输出local-&gt;server日志即可 123456789101112 // 进行转发 // 从 localUser 读取数据发送到 dstServer go func() &#123; err := localConn.DecodeCopy(dstServer) log.Println(time.Now(),"目标地址：", dstServer.RemoteAddr(),"源地址：", localConn.Address) // 增加 if err != nil &#123; // 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作 localConn.Close() dstServer.Close() &#125; &#125;()` server -&gt; local 日志 需要做以下修改 12345(&amp;SecureTCPConn&#123; Cipher: localConn.Cipher, Address: dstServer.RemoteAddr(), ReadWriteCloser: dstServer, &#125;).EncodeCopyServer(localConn) // 把EncodeCopy改为EncodeCopyServer方法 在securetcp创建EncodeCopyServer方法 1234func (secureSocket *SecureTCPConn) EncodeCopyServer(dst *SecureTCPConn) error &#123; log.Println(time.Now(),"目标地址：", dst.Address,"源地址：", secureSocket.Address) return secureSocket.EncodeCopy(dst)&#125; 现在运行，可以看到有日志的输出。 修改后代码可见github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NAT一探究竟]]></title>
      <url>%2F04%2F10%2FNAT%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F%2F</url>
      <content type="text"><![CDATA[前言一直好奇socket在内网情况下，是如何和外网链接的。如果都是私有ip还好理解，可以相互通信。但是公有ip都可以用，数据是怎么返回就成了一个迷。 由于最近需要抓取内网与外网交换的数据包，涉及到了内网ip与外网ip的转化，之前用的代理软件把ip给隐藏掉了，看不到是谁发过来的信息。需要自己编写一个代理软件，涉及到socket，顺便把NAT也探究一下。 NAT基本原理及应用标题是外部链接 P2P，UDP和TCP穿透NAT标题是外部链接 搭建NAT服务器先记下，等有了两个网卡，在尝试。 Linux服务器 Win服务器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络代理分析]]></title>
      <url>%2F04%2F10%2F%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90%E7%BC%96%E5%86%99%2F</url>
      <content type="text"><![CDATA[抓包分析 http 是通过tcp进行传输的， socket又是tcp的抽象，http直接通过socket就可以传输。做代理的话，不用管http，直接socket转发就可以。http会自己根据多个tcp组装起一个完整的数据。 抓包时，不小心抓到了https。https通过ssl传输。通过查找，比较同意这个说法。在https与tcp之间，SSL在技术上位于应用层，但从开发者的角度看，它是一个提供TCP服务的运输层协议。 不管怎么说，最终都是通过tcp传输。 代码分析一个轻巧的网络混淆代理-pythonpython 编写，大佬就是大佬，代码不是拿来用的，简直就是用来欣赏的。基本都是异步的，采用asyncio包写了很多的异步执行的方法。在代码中，网络传输用的是socket直接把数据转发，从而达到代理的作用。 一个轻巧的网络混淆代理-gogo 编写， 想法的提出者，一篇博客详细介绍了如何编写一个Shadowsocks 总结通过分析抓取的数据包与混淆代理代码，收获不少。之前一直把socket当作应用层，现在才发现socket是传输层的一个抽象，http可以直接通过socket进行传输。传输方法可以参考这一篇博客。加深了对传输透明的理解。不用管其他层做的事情，把对应层做好，就没得问题。 http与https]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[go 爬虫]]></title>
      <url>%2F04%2F09%2FGoSpider%2F</url>
      <content type="text"><![CDATA[需要的 net/http 请求网络 正则表达式 提取内容 encode/json 解析json os 创建文件 并发 豆瓣电影评分获取请求12345678910111213141516response, err := http.Get(url)if err != nil &#123; return&#125;buf := make([]byte, 4096)var str stringfor true &#123; n, err := response.Body.Read(buf) if n == 0 &#123; break &#125; if err != nil &amp;&amp; err != io.EOF &#123; return &#125; str += string(buf[:n])&#125; 正则表达式通过正则表达式获取内容 123456789reg1 := regexp.MustCompile(`&lt;img width="100" alt="(?s:(.*?))"`)reg2 := regexp.MustCompile(`&lt;span class="rating_num" property="v:average"&gt;(?s:(.*?))&lt;/span&gt;`)reg3 := regexp.MustCompile(`&lt;span&gt;(?s:(\d*?))人评价&lt;/span&gt;`)str1 := reg1.FindAllStringSubmatch(str, -1)str2 := reg2.FindAllStringSubmatch(str, -1)str3 := reg3.FindAllStringSubmatch(str, -1)for v := range str3&#123; fmt.Println(str1[v],str2[v],str3[v])&#125; 全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//https://movie.douban.com/top250?start=75&amp;filter=// &lt;img width="100" alt="//&lt;span class="rating_num" property="v:average"&gt;8.7&lt;/span&gt;// &lt;span&gt;620194人评价&lt;/span&gt;func spider(url string, page chan int, v int) &#123; response, err := http.Get(url) if err != nil &#123; return &#125; buf := make([]byte, 4096) var str string for true &#123; n, err := response.Body.Read(buf) if n == 0 &#123; break &#125; if err != nil &amp;&amp; err != io.EOF &#123; return &#125; str += string(buf[:n]) &#125; reg1 := regexp.MustCompile(`&lt;img width="100" alt="(?s:(.*?))"`) reg2 := regexp.MustCompile(`&lt;span class="rating_num" property="v:average"&gt;(?s:(.*?))&lt;/span&gt;`) reg3 := regexp.MustCompile(`&lt;span&gt;(?s:(\d*?))人评价&lt;/span&gt;`) str1 := reg1.FindAllStringSubmatch(str, -1) str2 := reg2.FindAllStringSubmatch(str, -1) str3 := reg3.FindAllStringSubmatch(str, -1) for v := range str3&#123; fmt.Println(str1[v],str2[v],str3[v]) &#125; defer response.Body.Close() page &lt;- v&#125;func working(start int, end int) &#123; page := make(chan int) for v := start; v &lt;= end; v++ &#123; url := fmt.Sprintf("https://movie.douban.com/top250?start=%d&amp;filter=", v*25) go spider(url, page, v) &#125; for v := start; v &lt;= end; v++ &#123; fmt.Println(&lt;-page) &#125;&#125;func main() &#123; var start, end int fmt.Scan(&amp;start) fmt.Scan(&amp;end) working(start, end)&#125; 斗鱼斗鱼通过后端传json到前端，然后解析json，在前端显示。请求部分同上 json解析部分12345678jsonContent:=make(map[string]interface&#123;&#125;)_ = json.Unmarshal([]byte(str),&amp;jsonContent)data := jsonContent["data"]data2 := data.(map[string]interface&#123;&#125;)data3 := data2["rl"].([]interface&#123;&#125;)for v := range data3&#123; fmt.Println(data3[v].(map[string]interface&#123;&#125;)["rs16"])&#125; json解析需要成一个string:interface{}的字典。空接口类型需要自己断言。一层一层找到需要的数据。 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import ( "encoding/json" "fmt" "io" "net/http" "strconv")// https://www.douyu.com/gapi/rknc/directory/yzRec/4func spider(v int, page chan int) &#123; url := "https://www.douyu.com/gapi/rknc/directory/yzRec/"+strconv.Itoa(v) response, err := http.Get(url) if err != nil&#123; page &lt;- v return &#125; var str string buf := make([]byte, 4096) for true &#123; n, err:= response.Body.Read(buf) if n == 0 &#123; break &#125; if err != nil &amp;&amp; err != io.EOF &#123; page &lt;- v return &#125; str += string(buf[:n]) &#125; defer response.Body.Close() //json.Unmarshal([]byte(str), ) //reg := regexp.MustCompile(`(https://rpic.douyucdn.cn/live-cover/.*?)"`) //pngs := reg.FindAllStringSubmatch(str, -1) //for v:= range pngs&#123; // fmt.Println(pngs[v]) //&#125; jsonContent:=make(map[string]interface&#123;&#125;) _ = json.Unmarshal([]byte(str),&amp;jsonContent) data := jsonContent["data"] data2 := data.(map[string]interface&#123;&#125;) data3 := data2["rl"].([]interface&#123;&#125;) for v := range data3&#123; fmt.Println(data3[v].(map[string]interface&#123;&#125;)["rs16"]) &#125; page &lt;- v&#125;func DouSpider(start int, end int) &#123; page := make(chan int) for v := start; v &lt;= end; v++ &#123; go spider(v, page) &#125; for v := start; v &lt;= end; v++ &#123; fmt.Println(&lt;-page) &#125;&#125;func main() &#123; var start, end int fmt.Scan(&amp;start) fmt.Scan(&amp;end) DouSpider(start, end)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GoNote]]></title>
      <url>%2F04%2F09%2FGoNote%2F</url>
      <content type="text"><![CDATA[函数类型 匿名函数go 函数也是一种类型，用于声明变量，接收变量值 12345678910package mainimport "fmt"type myFunc func(a int, b int) intfunc main()&#123; var myfunc myFunc myfunc = func(a int, b int) int &#123; return a+b &#125; fmt.Println(myfunc(1,2))&#125; 回调函数把函数当作一个参数 12345678910111213type myFunc func(a int, b int) intfunc calu(a int, b int, myfunc myFunc) int &#123; return myfunc(a, b)&#125;func main()&#123; var myfunc myFunc myfunc = func(a int, b int) int &#123; return a+b &#125; fmt.Println(calu(1,2, myfunc))&#125; 闭包闭包中变量，一直存在 12345678910111213func test02() func() int&#123; vv := 1 return func() int&#123; vv++ return vv &#125;&#125;func main()&#123; f := test02() fmt.Println(f()) fmt.Println(f())&#125; 匿名导入1import _ "fmt" 执行init函数 匿名字段继承 定义与初始化12345678910111213141516171819202122232425type people struct&#123; name string age int sex byte&#125;type student struct&#123; people id int&#125;func main() &#123; s := student&#123;people&#123;"aa",16,'m'&#125;,150706&#125; fmt.Println(s) s2 := student&#123;people:people&#123;name:"bb"&#125; id:160706&#125; fmt.Println(s2) // s3 := student&#123;"aa",16,'m',150706&#125; 错误用法 s4 := student&#123;&#125; s4.id = 170706 s4.name = "cc" s4.age = 17 s4.sex = 'm' fmt.Println(s4)&#125; 非结构字段12345678910111213141516171819202122type people struct&#123; name string age int sex byte&#125;type student struct&#123; people int&#125;func main() &#123; s := student&#123;people&#123;"aa",16,'m'&#125;,150706&#125; fmt.Println(s) s4 := student&#123;&#125; s4.int = 170706 s4.name = "cc" s4.age = 17 s4.sex = 'm' fmt.Println(s4)&#125; 同名字段就近原则 方法值与引用12345678910111213141516171819202122232425type people struct&#123; name string age int sex byte&#125;func (this *people) setinfoPointer()&#123; this.name = "a" this.age = 12 this.sex = 'm'&#125;func (this people) setinfo()&#123; this.name = "a" this.age = 12 this.sex = 'm'&#125;func main() &#123; p := people&#123;&#125; p.setinfo() // 无效 fmt.Println(p) p.setinfoPointer() fmt.Println(p)&#125; 接口空接口 类型断言12345678910111213141516171819202122232425262728293031type people struct&#123; name string age int sex byte&#125;func main() &#123; ii := make([]interface&#123;&#125;, 3) ii[0] = 1 ii[1] = "2" ii[2] = people&#123;name:"3"&#125; for _,d := range ii &#123; if val, ok:=d.(int); ok&#123; fmt.Println("int",val) &#125;else if val, ok:=d.(string); ok&#123; fmt.Println("string",val) &#125;else if val, ok:=d.(people); ok&#123; fmt.Println("people",val) &#125; &#125; for _,d := range ii &#123; switch value := d.(type) &#123; case int: fmt.Println("int",value) case string: fmt.Println("string",value) case people: fmt.Println("people",value) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试准备]]></title>
      <url>%2F04%2F07%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
      <content type="text"><![CDATA[面试前准备 pythonpython面试题 javajava面试题 redisredis入门 rabbitmqrabbitmq复习 rabbitmq复习 springbootspringbootspringboot gogolang go]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shop_go_vue]]></title>
      <url>%2F04%2F05%2Fshop-go-vue%2F</url>
      <content type="text"><![CDATA[一个购物网站总结一个购物网站，数据库设计如下： 前端nodejs + vue-cli + Vue + Element-UI vue采用element-UI组件。记录一下体验： vue整体体验很好，通过router和router-view可以很好的提高前端布局代码的复用性。对我这种不擅长写前端，每次写前端ctrl+c，ctrl+v的真的是非常的友好。另外，数据的绑定、一些指令也是相当的好用 使用vue-cli工具，需要借助nodejs，可以实现前后端的分离。在vue-cli的工程上，目录结构很清晰，很容易写一个前端。不过需要一些nodejs的知识，不然学起来真的很难受。 element-UI组件很好使用，不用懂很多css也能写出来很漂亮页面，有种纯写html最后得到带css效果的页面。 笔记： 父子组件通信 v-model 数据双向绑定 v-on （@）事件 v-bind （:） 数据单向绑定 内置指令 v-if、v-else、v-else-if 条件 v-for 循环 （o, i） in objs 其中i是索引，这个顺序好像和我见过的大部分语言相反 函数 created watch 一直观察这个变量 computed 一个变量通过函数结算出来 slot、props、scope slot 插槽 scope props beegobeego体验： beego从入门到放弃，没有重新运行解决不了的问题，beego基于mvc三层的一个框架，只要学过其他语言的WEB，入手还是很容易的。 学习go语言一天，入手beego，本着练习go语言的原则，写了这个项目。 beego有个bee工具，使用起来很容易。bee generate 几乎直接把真的网站的代码都写完了，需要改一些逻辑。生成的controller中GetAll也太恨了，把整个数据库的信息可以按照任意条件都能查询到。 项目中遇到的问题： 通过注释配url，这个不知道是我的问题，还是beego的问题。配好的url，第一次不起作用，需要把进程关了，然后重新运行。第一次运行会生成一个文件，但是进入url会404，第二次运行就没问题。 beego的orm也很用，很简单的就能和数据库映射。查询外键中的对象很可以查询到，不过一旦用了外键，外键对应的就成为了一个结构体，在发post等请求时，传外键Id时，需要多写一个{}。 beego笔记： bee generate 生成代码 new 创建 pack 打包 run 运行 orm qs.RelatedSel() 加载外键 参数：要加载的外键名字，多层的话，可以使用__ qs.Limit(limit, offset) struct 123456789type Address struct &#123; Id int `orm:"column(aid);auto"` Uid *User `orm:"column(uid);null;rel(fk)"`&#125;// auto自增、// null可以为空、默认为非空、// auto_now_add;type(datetime) 自动放到当时时间// auto_now;type(datetime) 自动放到当时时间// 区别auto_now_add第一次添加的时间，更新时间不变，auto_now每次更新时间改变 Controller router ServeJSON]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>%2F04%2F25%2Fhello%2F</url>
      <content type="text"><![CDATA[博客笔记 自2017年搭建好，再也没用过，两年后的现在重拾博客]]></content>
    </entry>

    
  
  
</search>
